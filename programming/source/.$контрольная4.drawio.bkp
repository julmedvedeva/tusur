<mxfile host="Electron" modified="2024-06-24T17:00:34.804Z" agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/24.5.1 Chrome/124.0.6367.207 Electron/30.0.6 Safari/537.36" etag="S6Pw3AcQLBVeTh6-ND4n" version="24.5.1" type="device" pages="2">
  <diagram id="C5RBs43oDa-KdzZeNtuy" name="задача1">
    <mxGraphModel dx="1468" dy="1118" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-0" />
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-1" parent="WIyWlLk6GJQsqaUBKTNV-0" />
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-2" value="" style="rounded=0;html=1;jettySize=auto;orthogonalLoop=1;fontSize=11;endArrow=block;endFill=0;endSize=8;strokeWidth=1;shadow=0;labelBackgroundColor=none;edgeStyle=orthogonalEdgeStyle;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="WIyWlLk6GJQsqaUBKTNV-3" target="WIyWlLk6GJQsqaUBKTNV-6" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-3" value="Lamp doesn&#39;t work" style="rounded=1;whiteSpace=wrap;html=1;fontSize=12;glass=0;strokeWidth=1;shadow=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="160" y="80" width="120" height="40" as="geometry" />
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-4" value="Yes" style="rounded=0;html=1;jettySize=auto;orthogonalLoop=1;fontSize=11;endArrow=block;endFill=0;endSize=8;strokeWidth=1;shadow=0;labelBackgroundColor=none;edgeStyle=orthogonalEdgeStyle;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="WIyWlLk6GJQsqaUBKTNV-6" target="WIyWlLk6GJQsqaUBKTNV-10" edge="1">
          <mxGeometry y="20" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-5" value="No" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;jettySize=auto;orthogonalLoop=1;fontSize=11;endArrow=block;endFill=0;endSize=8;strokeWidth=1;shadow=0;labelBackgroundColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="WIyWlLk6GJQsqaUBKTNV-6" target="WIyWlLk6GJQsqaUBKTNV-7" edge="1">
          <mxGeometry y="10" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-6" value="Lamp&lt;br&gt;plugged in?" style="rhombus;whiteSpace=wrap;html=1;shadow=0;fontFamily=Helvetica;fontSize=12;align=center;strokeWidth=1;spacing=6;spacingTop=-4;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="170" y="170" width="100" height="80" as="geometry" />
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-7" value="Plug in lamp" style="rounded=1;whiteSpace=wrap;html=1;fontSize=12;glass=0;strokeWidth=1;shadow=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="320" y="190" width="120" height="40" as="geometry" />
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-8" value="No" style="rounded=0;html=1;jettySize=auto;orthogonalLoop=1;fontSize=11;endArrow=block;endFill=0;endSize=8;strokeWidth=1;shadow=0;labelBackgroundColor=none;edgeStyle=orthogonalEdgeStyle;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="WIyWlLk6GJQsqaUBKTNV-10" target="WIyWlLk6GJQsqaUBKTNV-11" edge="1">
          <mxGeometry x="0.3333" y="20" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-9" value="Yes" style="edgeStyle=orthogonalEdgeStyle;rounded=0;html=1;jettySize=auto;orthogonalLoop=1;fontSize=11;endArrow=block;endFill=0;endSize=8;strokeWidth=1;shadow=0;labelBackgroundColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="WIyWlLk6GJQsqaUBKTNV-10" target="WIyWlLk6GJQsqaUBKTNV-12" edge="1">
          <mxGeometry y="10" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-10" value="Bulb&lt;br&gt;burned out?" style="rhombus;whiteSpace=wrap;html=1;shadow=0;fontFamily=Helvetica;fontSize=12;align=center;strokeWidth=1;spacing=6;spacingTop=-4;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="170" y="290" width="100" height="80" as="geometry" />
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-11" value="Repair Lamp" style="rounded=1;whiteSpace=wrap;html=1;fontSize=12;glass=0;strokeWidth=1;shadow=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="160" y="430" width="120" height="40" as="geometry" />
        </mxCell>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-12" value="Replace Bulb" style="rounded=1;whiteSpace=wrap;html=1;fontSize=12;glass=0;strokeWidth=1;shadow=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="320" y="310" width="120" height="40" as="geometry" />
        </mxCell>
        <UserObject label="Для создания блок-схемы для алгоритма работы со связанным списком в соответствии с вашим описанием, можно использовать следующие блоки:&#xa;&#xa;&#xa;1. **InitializeList**&#xa;   - Вход: List&#xa;   - Действие: Установить `List.Head` и `List.Tail` в `nil`&#xa;   - Выход: Инициализированный пустой список&#xa;&#xa;&#xa;2. **AddToList**&#xa;   - Вход: List, Value&#xa;   - Действие:&#xa;     - Создать новый узел (NewNode)&#xa;     - Установить `NewNode^.Data` = Value&#xa;     - Установить `NewNode^.Next` = nil&#xa;     - Если `List.Head` = nil, установить `List.Head` = NewNode&#xa;     - Иначе установить `List.Tail^.Next` = NewNode&#xa;     - Установить `List.Tail` = NewNode&#xa;   - Выход: Список с добавленным элементом&#xa;&#xa;&#xa;3. **PrintList**&#xa;   - Вход: List&#xa;   - Действие:&#xa;     - Установить `Current` = `List.Head`&#xa;     - Пока `Current` &lt;&gt; nil:&#xa;       - Вывести `Current^.Data`&#xa;       - Установить `Current` = `Current^.Next`&#xa;   - Выход: Вывод элементов списка&#xa;&#xa;&#xa;4. **SwapFirstAndLast**&#xa;   - Вход: List&#xa;   - Действие:&#xa;     - Проверить, что список не пуст и содержит более одного элемента (`List.Head` &lt;&gt; nil и `List.Head` &lt;&gt; `List.Tail`)&#xa;     - Найти последний элемент (`Last` = `List.Tail`) и первый элемент (`Current` = `List.Head`)&#xa;     - Найти предпоследний элемент (пока `Current^.Next` &lt;&gt; `Last`, `Current` = `Current^.Next`)&#xa;     - Обменять местами `Head`, `Next` последнего и первого элементов, а также обновить `Tail`&#xa;   - Выход: Список с замененными первым и последним элементами&#xa;&#xa;&#xa;5. **RemoveLastElement**&#xa;   - Вход: List&#xa;   - Действие:&#xa;     - Проверить, что список не пуст (`List.Head` &lt;&gt; nil)&#xa;     - Инициализировать `Current` и `Prev` на начало списка (`Current` = `List.Head`, `Prev` = nil)&#xa;     - Найти последний элемент (пока `Current^.Next` &lt;&gt; nil, `Prev` = `Current`, `Current` = `Current^.Next`)&#xa;     - Если `Prev` = nil, установить `List.Head` = nil&#xa;     - Иначе установить `Prev^.Next` = nil и `List.Tail` = `Prev`&#xa;     - Освободить память, занятую удаленным элементом (`Dispose(Current)`)&#xa;   - Выход: Список с удаленным последним элементом&#xa;&#xa;&#xa;Ниже представлена блок-схема, основанная на этих описаниях:&#xa;&#xa;&#xa;![Блок-схема](https://i.imgur.com/eXQaDY0.png)&#xa;&#xa;&#xa;1. **Инициализация списка**&#xa;   - Начало&#xa;   - Установить `List.Head` и `List.Tail` в `nil`&#xa;   - Конец&#xa;&#xa;&#xa;2. **Добавление элемента в конец списка**&#xa;   - Начало&#xa;   - Создать `NewNode`&#xa;   - Установить `NewNode^.Data` = Value&#xa;   - Установить `NewNode^.Next` = nil&#xa;   - `List.Head` = nil?&#xa;     - Да: Установить `List.Head` = NewNode&#xa;     - Нет: Установить `List.Tail^.Next` = NewNode&#xa;   - Установить `List.Tail` = NewNode&#xa;   - Конец&#xa;&#xa;&#xa;3. **Печать элементов списка**&#xa;   - Начало&#xa;   - Установить `Current` = `List.Head`&#xa;   - `Current` &lt;&gt; nil?&#xa;     - Да: Вывести `Current^.Data`&#xa;           Установить `Current` = `Current^.Next`&#xa;     - Нет: Конец цикла&#xa;   - Конец&#xa;&#xa;&#xa;4. **Замена первого и последнего элементов**&#xa;   - Начало&#xa;   - Список пуст или содержит один элемент?&#xa;     - Да: Конец&#xa;     - Нет: Найти последний элемент (`Last` = `List.Tail`) и первый элемент (`Current` = `List.Head`)&#xa;             Найти предпоследний элемент&#xa;             Обменять `Head`, `Next` последнего и первого элементов&#xa;             Обновить `Tail`&#xa;   - Конец&#xa;&#xa;&#xa;5. **Удаление последнего элемента**&#xa;   - Начало&#xa;   - Список пуст?&#xa;     - Да: Конец&#xa;     - Нет: Найти последний элемент (`Current` = `List.Head`, `Prev` = nil)&#xa;             Пока `Current^.Next` &lt;&gt; nil, `Prev` = `Current`, `Current` = `Current^.Next`&#xa;             Если `Prev` = nil, установить `List.Head` = nil&#xa;             Иначе установить `Prev^.Next` = nil и `List.Tail` = `Prev`&#xa;             Освободить память (`Dispose(Current)`)&#xa;   - Конец&#xa;&#xa;&#xa;Это визуальное представление алгоритма поможет лучше понять структуру и последовательность действий программы." link="Для создания блок-схемы для алгоритма работы со связанным списком в соответствии с вашим описанием, можно использовать следующие блоки:&#xa;&#xa;&#xa;1. **InitializeList**&#xa;   - Вход: List&#xa;   - Действие: Установить `List.Head` и `List.Tail` в `nil`&#xa;   - Выход: Инициализированный пустой список&#xa;&#xa;&#xa;2. **AddToList**&#xa;   - Вход: List, Value&#xa;   - Действие:&#xa;     - Создать новый узел (NewNode)&#xa;     - Установить `NewNode^.Data` = Value&#xa;     - Установить `NewNode^.Next` = nil&#xa;     - Если `List.Head` = nil, установить `List.Head` = NewNode&#xa;     - Иначе установить `List.Tail^.Next` = NewNode&#xa;     - Установить `List.Tail` = NewNode&#xa;   - Выход: Список с добавленным элементом&#xa;&#xa;&#xa;3. **PrintList**&#xa;   - Вход: List&#xa;   - Действие:&#xa;     - Установить `Current` = `List.Head`&#xa;     - Пока `Current` &lt;&gt; nil:&#xa;       - Вывести `Current^.Data`&#xa;       - Установить `Current` = `Current^.Next`&#xa;   - Выход: Вывод элементов списка&#xa;&#xa;&#xa;4. **SwapFirstAndLast**&#xa;   - Вход: List&#xa;   - Действие:&#xa;     - Проверить, что список не пуст и содержит более одного элемента (`List.Head` &lt;&gt; nil и `List.Head` &lt;&gt; `List.Tail`)&#xa;     - Найти последний элемент (`Last` = `List.Tail`) и первый элемент (`Current` = `List.Head`)&#xa;     - Найти предпоследний элемент (пока `Current^.Next` &lt;&gt; `Last`, `Current` = `Current^.Next`)&#xa;     - Обменять местами `Head`, `Next` последнего и первого элементов, а также обновить `Tail`&#xa;   - Выход: Список с замененными первым и последним элементами&#xa;&#xa;&#xa;5. **RemoveLastElement**&#xa;   - Вход: List&#xa;   - Действие:&#xa;     - Проверить, что список не пуст (`List.Head` &lt;&gt; nil)&#xa;     - Инициализировать `Current` и `Prev` на начало списка (`Current` = `List.Head`, `Prev` = nil)&#xa;     - Найти последний элемент (пока `Current^.Next` &lt;&gt; nil, `Prev` = `Current`, `Current` = `Current^.Next`)&#xa;     - Если `Prev` = nil, установить `List.Head` = nil&#xa;     - Иначе установить `Prev^.Next` = nil и `List.Tail` = `Prev`&#xa;     - Освободить память, занятую удаленным элементом (`Dispose(Current)`)&#xa;   - Выход: Список с удаленным последним элементом&#xa;&#xa;&#xa;Ниже представлена блок-схема, основанная на этих описаниях:&#xa;&#xa;&#xa;![Блок-схема](https://i.imgur.com/eXQaDY0.png)&#xa;&#xa;&#xa;1. **Инициализация списка**&#xa;   - Начало&#xa;   - Установить `List.Head` и `List.Tail` в `nil`&#xa;   - Конец&#xa;&#xa;&#xa;2. **Добавление элемента в конец списка**&#xa;   - Начало&#xa;   - Создать `NewNode`&#xa;   - Установить `NewNode^.Data` = Value&#xa;   - Установить `NewNode^.Next` = nil&#xa;   - `List.Head` = nil?&#xa;     - Да: Установить `List.Head` = NewNode&#xa;     - Нет: Установить `List.Tail^.Next` = NewNode&#xa;   - Установить `List.Tail` = NewNode&#xa;   - Конец&#xa;&#xa;&#xa;3. **Печать элементов списка**&#xa;   - Начало&#xa;   - Установить `Current` = `List.Head`&#xa;   - `Current` &lt;&gt; nil?&#xa;     - Да: Вывести `Current^.Data`&#xa;           Установить `Current` = `Current^.Next`&#xa;     - Нет: Конец цикла&#xa;   - Конец&#xa;&#xa;&#xa;4. **Замена первого и последнего элементов**&#xa;   - Начало&#xa;   - Список пуст или содержит один элемент?&#xa;     - Да: Конец&#xa;     - Нет: Найти последний элемент (`Last` = `List.Tail`) и первый элемент (`Current` = `List.Head`)&#xa;             Найти предпоследний элемент&#xa;             Обменять `Head`, `Next` последнего и первого элементов&#xa;             Обновить `Tail`&#xa;   - Конец&#xa;&#xa;&#xa;5. **Удаление последнего элемента**&#xa;   - Начало&#xa;   - Список пуст?&#xa;     - Да: Конец&#xa;     - Нет: Найти последний элемент (`Current` = `List.Head`, `Prev` = nil)&#xa;             Пока `Current^.Next` &lt;&gt; nil, `Prev` = `Current`, `Current` = `Current^.Next`&#xa;             Если `Prev` = nil, установить `List.Head` = nil&#xa;             Иначе установить `Prev^.Next` = nil и `List.Tail` = `Prev`&#xa;             Освободить память (`Dispose(Current)`)&#xa;   - Конец&#xa;&#xa;&#xa;Это визуальное представление алгоритма поможет лучше понять структуру и последовательность действий программы." id="hYftv4fvOJJcl0ROjEqP-0">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="WIyWlLk6GJQsqaUBKTNV-1">
            <mxGeometry x="720" y="60" width="560" height="1740" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
  <diagram id="NZ7e3xII85pv3wF8psCJ" name="задача2">
    <mxGraphModel dx="1193" dy="909" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="583" pageHeight="827" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <UserObject label="### Блок-схема алгоритма генерации координат кардиоиды и записи их в файл&#xa;&#xa;&#xa;1. **Поля класса**:&#xa;   - `FileName`: Строка для хранения имени файла, в который будут записаны координаты кардиоиды.&#xa;&#xa;&#xa;2. **Метод `Create`**:&#xa;   - Конструктор класса, который инициализирует поле `FileName`.&#xa;&#xa;&#xa;3. **Приватный метод `WriteCardioidCoordinates`**:&#xa;   - Открывает файл для записи и генерирует координаты кардиоиды.&#xa;   - Использует параметрические уравнения кардиоиды для вычисления координат `x` и `y`.&#xa;   - Записывает координаты в файл в формате &quot;x, y&quot;.&#xa;   - Закрывает файл после завершения записи.&#xa;&#xa;&#xa;4. **Публичный метод `Generate`**:&#xa;   - Вызывает метод `WriteCardioidCoordinates`, чтобы сгенерировать и записать координаты кардиоиды в файл.&#xa;&#xa;&#xa;5. **Основная программа**:&#xa;   - Создает экземпляр класса `CardioidGenerator` с указанием имени файла.&#xa;   - Вызывает метод `Generate` для выполнения генерации координат.&#xa;&#xa;&#xa;### Блок-схема:&#xa;&#xa;&#xa;```plaintext&#xa;+---------------------------------------------------+&#xa;|                   Основная программа              |&#xa;+---------------------------------------------------+&#xa;| 1. Создать экземпляр класса CardioidGenerator     |&#xa;| 2. Вызвать метод Generate                         |&#xa;+---------------------------------------------------+&#xa;                      |&#xa;                      V&#xa;+---------------------------------------------------+&#xa;|           Конструктор класса Create               |&#xa;+---------------------------------------------------+&#xa;| 1. Принять имя файла как параметр                 |&#xa;| 2. Инициализировать поле FileName                 |&#xa;+---------------------------------------------------+&#xa;                      |&#xa;                      V&#xa;+---------------------------------------------------+&#xa;|            Публичный метод Generate               |&#xa;+---------------------------------------------------+&#xa;| 1. Вызвать метод WriteCardioidCoordinates         |&#xa;+---------------------------------------------------+&#xa;                      |&#xa;                      V&#xa;+---------------------------------------------------+&#xa;|        Приватный метод WriteCardioidCoordinates   |&#xa;+---------------------------------------------------+&#xa;| 1. Открыть файл для записи                        |&#xa;| 2. Цикл от 0 до NumPoints-1                       |&#xa;|    a. Вычислить t = 2 * Pi * i / NumPoints        |&#xa;|    b. Вычислить x = a * cos(t) * (1 + cos(t))     |&#xa;|    c. Вычислить y = a * sin(t) * (1 + cos(t))     |&#xa;|    d. Записать координаты x и y в файл            |&#xa;| 3. Закрыть файл                                   |&#xa;+---------------------------------------------------+&#xa;```&#xa;&#xa;&#xa;### Описание блок-схемы:&#xa;&#xa;&#xa;1. **Основная программа**:&#xa;   - Создает экземпляр класса `CardioidGenerator`.&#xa;   - Вызывает метод `Generate`.&#xa;&#xa;&#xa;2. **Конструктор класса `Create`**:&#xa;   - Принимает имя файла в качестве параметра и инициализирует поле `FileName`.&#xa;&#xa;&#xa;3. **Публичный метод `Generate`**:&#xa;   - Вызывает приватный метод `WriteCardioidCoordinates`.&#xa;&#xa;&#xa;4. **Приватный метод `WriteCardioidCoordinates`**:&#xa;   - Открывает файл для записи.&#xa;   - В цикле от 0 до `NumPoints-1`:&#xa;     - Вычисляет значение параметра `t`.&#xa;     - Использует параметрические уравнения для вычисления координат `x` и `y`.&#xa;     - Записывает координаты в файл в формате &quot;x, y&quot;.&#xa;   - Закрывает файл после завершения записи.&#xa;&#xa;&#xa;### Графическое представление&#xa;&#xa;&#xa;Для графического представления блок-схемы, можно использовать инструменты, такие как draw.io, Lucidchart или любые другие инструменты для создания блок-схем. Вот как это может выглядеть визуально:&#xa;&#xa;&#xa;1. Начало&#xa;2. Основная программа:&#xa;   - Создать экземпляр класса `CardioidGenerator`&#xa;   - Вызвать метод `Generate`&#xa;3. Конструктор `Create`:&#xa;   - Принять имя файла как параметр&#xa;   - Инициализировать поле `FileName`&#xa;4. Метод `Generate`:&#xa;   - Вызвать метод `WriteCardioidCoordinates`&#xa;5. Метод `WriteCardioidCoordinates`:&#xa;   - Открыть файл для записи&#xa;   - Цикл от 0 до `NumPoints-1`:&#xa;     - Вычислить `t`&#xa;     - Вычислить `x` и `y`&#xa;     - Записать координаты в файл&#xa;   - Закрыть файл&#xa;6. Конец&#xa;&#xa;&#xa;Каждый из этих шагов можно представить в виде блоков, соединенных стрелками, чтобы показать поток управления и выполнения программы." id="P2P8IGDHMc5wjiAtll5v-1">
          <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
            <mxGeometry x="300" y="270" width="560" height="1820" as="geometry" />
          </mxCell>
        </UserObject>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
