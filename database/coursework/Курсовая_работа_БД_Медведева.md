# КУРСОВАЯ РАБОТА

## По дисциплине «Базы данных»

### Тема: «Разработка информационной системы учёта пациентов и приёмов в поликлинике»

---

**Выполнила:**
студентка группы _______
Медведева Ю.Е.

**Проверил:**
_______________________

---

Томск 2024

---

# ЗАДАНИЕ НА КУРСОВУЮ РАБОТУ

**Тема:** Разработка информационной системы учёта пациентов и приёмов в поликлинике

**Цель работы:** Спроектировать и реализовать реляционную базу данных для автоматизации процессов регистрации пациентов, записи на приёмы, ведения медицинской документации и формирования отчётов в условиях поликлиники.

**Основные задачи:**

1. Провести анализ предметной области и выявить основные сущности и связи между ними
2. Разработать концептуальную модель данных (ER-диаграмма)
3. Спроектировать логическую модель реляционной базы данных
4. Реализовать физическую модель в СУБД PostgreSQL
5. Разработать серверную часть на Node.js с использованием REST API
6. Создать клиентское веб-приложение на React
7. Протестировать работоспособность системы на типовых сценариях
8. Оформить техническую документацию

**Исходные данные:**
- Требования к функциональности системы учёта пациентов
- Справочники МКБ-10, типов кабинетов, медицинских процедур
- Примеры бизнес-процессов поликлиники

**Срок сдачи:** __________

---

# РЕФЕРАТ

Медведева Ю.Е. Разработка информационной системы учёта пациентов и приёмов в поликлинике. Курсовая работа. – Томск: ТУСУР, 2024. – ___ с.

**Ключевые слова:** база данных, реляционная модель, PostgreSQL, Node.js, React, информационная система, медицинский учёт, REST API, веб-приложение.

**Объект исследования:** процессы учёта пациентов, записи на приёмы и ведения медицинской документации в поликлинике.

**Цель работы:** разработка информационной системы для автоматизации процессов регистрации пациентов, управления расписанием врачей, ведения медицинских записей и формирования отчётов.

**Метод исследования:** проектирование реляционных баз данных, объектно-ориентированное программирование, технологии веб-разработки.

**Полученные результаты:** спроектирована и реализована полнофункциональная информационная система на основе СУБД PostgreSQL с веб-интерфейсом. Система включает 22 таблицы, более 30 API-эндпоинтов и интерактивный пользовательский интерфейс. Реализованы механизмы валидации данных, поддержка справочников, фильтрация и экспорт отчётов в формате CSV.

**Область применения:** медицинские учреждения амбулаторного типа (поликлиники, амбулатории, медицинские центры).

---

# СОДЕРЖАНИЕ

1. ВВЕДЕНИЕ
2. ГЛАВА 1. ТЕОРЕТИЧЕСКАЯ ЧАСТЬ
   - 1.1. Анализ предметной области
   - 1.2. Основные понятия реляционных баз данных
   - 1.3. Язык SQL и система управления базами данных PostgreSQL
   - 1.4. Архитектура клиент-серверных приложений
3. ГЛАВА 2. ПРАКТИЧЕСКАЯ ЧАСТЬ
   - 2.1. Концептуальное проектирование базы данных
   - 2.2. Логическое проектирование
   - 2.3. Физическая реализация в PostgreSQL
   - 2.4. Разработка серверной части (Node.js + Express)
   - 2.5. Разработка клиентской части (React)
   - 2.6. Тестирование и отладка
4. ЗАКЛЮЧЕНИЕ
5. СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ
6. ПРИЛОЖЕНИЯ

---

# ВВЕДЕНИЕ

## Актуальность темы

В современных условиях цифровизации здравоохранения вопросы эффективного управления медицинской информацией приобретают особую значимость. Поликлиники ежедневно обслуживают сотни пациентов, и качество медицинской помощи напрямую зависит от оперативности доступа к информации о пациентах, их истории болезни и результатах обследований.

Традиционные методы ведения медицинской документации на бумажных носителях имеют существенные недостатки: низкая скорость поиска информации, риск потери данных, сложность формирования аналитических отчётов, дублирование информации. Внедрение информационных систем позволяет решить эти проблемы и повысить качество обслуживания пациентов.

## Цели и задачи исследования

**Цель курсовой работы:** разработать информационную систему для автоматизации процессов учёта пациентов, записи на приёмы и ведения медицинской документации в поликлинике.

**Задачи:**

1. Изучить предметную область и выделить основные сущности и бизнес-процессы поликлиники
2. Спроектировать концептуальную модель данных с использованием ER-диаграмм
3. Разработать логическую модель реляционной базы данных с учётом нормализации
4. Реализовать физическую модель в СУБД PostgreSQL
5. Создать серверное приложение на Node.js с REST API
6. Разработать клиентское веб-приложение на React
7. Провести функциональное тестирование системы
8. Оформить техническую документацию проекта

## Объект и предмет исследования

**Объект исследования:** информационные процессы в медицинском учреждении амбулаторного типа (поликлинике).

**Предмет исследования:** методы проектирования и реализации реляционных баз данных для автоматизации учёта пациентов и управления медицинской документацией.

## Методы исследования

При выполнении курсовой работы применялись следующие методы:

- Системный анализ предметной области
- Методология проектирования баз данных (концептуальное, логическое, физическое проектирование)
- Нормализация отношений (до третьей нормальной формы)
- Объектно-ориентированное программирование
- Архитектурный подход REST (Representational State Transfer)
- Методы тестирования программного обеспечения

## Краткое описание структуры работы

Курсовая работа состоит из введения, двух глав, заключения, списка литературы и приложений.

В первой главе рассматриваются теоретические основы проектирования реляционных баз данных, описываются основные понятия и принципы работы СУБД PostgreSQL, а также архитектура клиент-серверных веб-приложений.

Во второй главе представлена практическая реализация информационной системы: от концептуального проектирования до разработки полнофункционального веб-приложения с пользовательским интерфейсом.

В заключении подводятся итоги проделанной работы, анализируются достигнутые результаты и формулируются рекомендации по дальнейшему развитию системы.

---

# ГЛАВА 1. ТЕОРЕТИЧЕСКАЯ ЧАСТЬ

## 1.1. Анализ предметной области

### 1.1.1. Описание предметной области

Поликлиника – это медицинское учреждение, оказывающее амбулаторную (внебольничную) медицинскую помощь населению. Основными функциями поликлиники являются:

- Регистрация и учёт пациентов
- Организация приёма врачей различных специальностей
- Ведение медицинской документации (амбулаторных карт)
- Назначение и проведение лабораторных исследований
- Назначение лечения (лекарственные препараты, процедуры)
- Формирование отчётности для вышестоящих организаций

### 1.1.2. Основные сущности и бизнес-процессы

**Пациент** – физическое лицо, обращающееся за медицинской помощью. Для каждого пациента хранятся персональные данные (ФИО, дата рождения, пол), контактная информация (телефон, адрес), документы (СНИЛС, полис ОМС).

**Врач** – медицинский работник, оказывающий медицинскую помощь пациентам. Врач может иметь одну или несколько специальностей (терапевт, кардиолог, невролог и т.д.).

**Приём** – запланированный или состоявшийся визит пациента к врачу в определённое время. Приём характеризуется статусом (запланирован, подтверждён, идёт приём, завершён, отменён, неявка).

**Медицинская запись** – результат приёма, содержащий информацию о жалобах пациента, проведённом осмотре, поставленном диагнозе и назначенном лечении.

**Диагноз** – заболевание, выявленное у пациента, классифицируемое по Международной классификации болезней 10-го пересмотра (МКБ-10).

**Анализ** – лабораторное исследование, назначенное пациенту (общий анализ крови, биохимический анализ и т.д.).

**Назначение** – предписание врача о приёме лекарственных препаратов или прохождении медицинских процедур.

**Справочники** – классификаторы и нормативно-справочная информация (специальности врачей, виды анализов, типы кабинетов, адресный классификатор).

### 1.1.3. Типовые бизнес-процессы

1. **Регистрация нового пациента:**
   - Сбор персональных данных
   - Проверка наличия полиса ОМС и СНИЛС
   - Создание записи в базе данных

2. **Запись на приём к врачу:**
   - Выбор врача и специальности
   - Выбор свободного времени в расписании
   - Создание записи о приёме

3. **Проведение приёма:**
   - Изменение статуса приёма на "идёт приём"
   - Внесение жалоб и результатов осмотра
   - Постановка диагноза
   - Назначение анализов, лекарств, процедур
   - Завершение приёма

4. **Получение результатов анализов:**
   - Изменение статуса анализа на "выполнен"
   - Внесение результатов
   - Уведомление врача и пациента

5. **Формирование отчётов:**
   - Выгрузка списков пациентов по критериям
   - Статистика посещений
   - Отчёты по заболеваемости

## 1.2. Основные понятия реляционных баз данных

### 1.2.1. Реляционная модель данных

Реляционная модель данных основана на математическом понятии отношения (relation). Данные представляются в виде таблиц, где:

- **Отношение (таблица)** – набор строк с одинаковой структурой
- **Кортеж (строка)** – отдельная запись в таблице
- **Атрибут (столбец)** – характеристика сущности
- **Домен** – множество допустимых значений атрибута
- **Ключ** – атрибут или набор атрибутов, однозначно идентифицирующий кортеж

### 1.2.2. Типы ключей

**Первичный ключ (Primary Key)** – уникальный идентификатор записи в таблице. Не может содержать значение NULL. В разработанной системе используются суррогатные ключи типа SERIAL (автоинкрементные целые числа).

**Внешний ключ (Foreign Key)** – атрибут, ссылающийся на первичный ключ другой таблицы. Обеспечивает ссылочную целостность данных.

**Уникальный ключ (Unique Key)** – атрибут или набор атрибутов, значения которых не должны повторяться (например, СНИЛС, полис ОМС).

### 1.2.3. Нормализация отношений

Нормализация – процесс преобразования базы данных к виду, отвечающему нормальным формам, для устранения избыточности и аномалий.

**Первая нормальная форма (1НФ):** все атрибуты атомарны (неделимы), нет повторяющихся групп.

**Вторая нормальная форма (2НФ):** выполняется 1НФ, и все неключевые атрибуты полностью зависят от первичного ключа.

**Третья нормальная форма (3НФ):** выполняется 2НФ, и все неключевые атрибуты независимы друг от друга.

В разработанной базе данных все таблицы приведены к третьей нормальной форме.

### 1.2.4. Типы связей между сущностями

**Один-ко-многим (1:N)** – одна запись в главной таблице связана с несколькими записями в подчинённой таблице (например, один пациент может иметь много приёмов).

**Многие-ко-многим (M:N)** – записи из обеих таблиц могут иметь множественные связи. Реализуется через промежуточную таблицу (например, врачи и специальности связаны через таблицу doctor_specialties).

**Один-к-одному (1:1)** – каждой записи в одной таблице соответствует не более одной записи в другой таблице (например, приём и медицинская запись).

## 1.3. Язык SQL и система управления базами данных PostgreSQL

### 1.3.1. Основы языка SQL

SQL (Structured Query Language) – декларативный язык структурированных запросов для работы с реляционными базами данных. Включает следующие группы команд:

**DDL (Data Definition Language)** – определение структуры данных:
- CREATE – создание объектов БД
- ALTER – изменение структуры
- DROP – удаление объектов

**DML (Data Manipulation Language)** – манипулирование данными:
- SELECT – выборка данных
- INSERT – вставка новых записей
- UPDATE – обновление данных
- DELETE – удаление записей

**DCL (Data Control Language)** – управление правами доступа:
- GRANT – предоставление прав
- REVOKE – отзыв прав

### 1.3.2. Особенности PostgreSQL

PostgreSQL – свободная объектно-реляционная система управления базами данных с открытым исходным кодом. Преимущества PostgreSQL:

- Полная поддержка стандарта SQL
- Расширенная система типов данных (включая JSON, массивы, геоданные)
- Поддержка пользовательских типов (ENUM)
- Развитая система ограничений целостности
- ACID-совместимость (атомарность, согласованность, изолированность, долговечность)
- Производительная система индексов
- Хорошая поддержка Unicode и работы с кириллицей

### 1.3.3. Ограничения целостности в PostgreSQL

**PRIMARY KEY** – первичный ключ, автоматически создаёт уникальный индекс.

**FOREIGN KEY** – внешний ключ с опциями ON DELETE и ON UPDATE:
- CASCADE – каскадное удаление/обновление
- RESTRICT – запрет операции при наличии связанных записей
- SET NULL – установка NULL
- SET DEFAULT – установка значения по умолчанию

**UNIQUE** – уникальность значений атрибута.

**CHECK** – проверочное ограничение (например, дата рождения не позднее текущей даты).

**NOT NULL** – запрет значений NULL.

## 1.4. Архитектура клиент-серверных приложений

### 1.4.1. Трёхуровневая архитектура

Разработанная информационная система построена по трёхуровневой архитектуре:

**Уровень данных** – СУБД PostgreSQL, хранящая все данные приложения.

**Уровень бизнес-логики** – серверное приложение на Node.js + Express, предоставляющее REST API.

**Уровень представления** – клиентское веб-приложение на React, работающее в браузере пользователя.

### 1.4.2. REST API

REST (Representational State Transfer) – архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Основные принципы:

- Использование HTTP-методов (GET, POST, PUT, DELETE)
- Представление ресурсов в виде URL
- Отсутствие сохранения состояния на сервере (stateless)
- Передача данных в формате JSON

Пример эндпоинтов системы:
- GET /api/patients – получение списка пациентов
- POST /api/patients – создание нового пациента
- PUT /api/patients/:id – обновление данных пациента
- DELETE /api/patients/:id – удаление пациента

### 1.4.3. Технологический стек

**Backend:**
- Node.js – серверная платформа на JavaScript
- Express – веб-фреймворк для Node.js
- pg (node-postgres) – драйвер для работы с PostgreSQL
- CORS – обработка кросс-доменных запросов

**Frontend:**
- React – библиотека для построения пользовательских интерфейсов
- React Router – маршрутизация в одностраничном приложении
- React Bootstrap – компоненты интерфейса
- Axios – HTTP-клиент для запросов к API

**Инфраструктура:**
- Docker – контейнеризация базы данных
- Git – система контроля версий

---

# ГЛАВА 2. ПРАКТИЧЕСКАЯ ЧАСТЬ

## 2.1. Концептуальное проектирование базы данных

### 2.1.1. ER-диаграмма

На этапе концептуального проектирования была разработана ER-диаграмма (Entity-Relationship diagram), отображающая основные сущности системы и связи между ними.

**Основные сущности:**
- Пациент (PATIENT)
- Врач (DOCTOR)
- Приём (APPOINTMENT)
- Медицинская запись (MEDICAL_RECORD)
- Диагноз (DIAGNOSIS)
- Анализ (ANALYSIS)
- Вид анализа (ANALYSIS_CATALOG)
- Лекарство (DRUG)
- Процедура (PROCEDURE)
- Специальность (SPECIALTY)
- Кабинет (ROOM)
- Расписание врачей (DOCTOR_ROOM)
- Назначение лекарства (PRESCRIPTION_DRUG)
- Назначение процедуры (PRESCRIPTION_PROCEDURE)
- Адресные справочники (COUNTRY, TOWN, STREET)

**Ключевые связи:**
- Пациент → Приём (1:N) – один пациент может иметь много приёмов
- Врач → Приём (1:N) – один врач проводит много приёмов
- Приём → Медицинская запись (1:1) – каждому приёму соответствует одна запись
- Врач ↔ Специальность (M:N) – врач может иметь несколько специальностей
- Медицинская запись → Диагноз (N:1) – одна запись содержит один основной диагноз
- Медицинская запись → Назначения (1:N) – одна запись может содержать много назначений
- Приём → Анализы (1:N) – на одном приёме может быть назначено несколько анализов

Полная ER-диаграмма представлена в Приложении А.

### 2.1.2. Выделение атрибутов сущностей

Для каждой сущности были определены атрибуты и их типы данных.

**Пациент (patients):**
- id – уникальный идентификатор
- last_name, first_name, patronymic – ФИО
- date_of_birth – дата рождения
- gender – пол (перечисление: male/female)
- phone_number – телефон
- email – электронная почта
- snils – СНИЛС (уникальный)
- insurance_policy – полис ОМС (уникальный)
- country_id, town_id, street_id – ссылки на адресные справочники
- building, apartment_number, zipcode – адрес

**Врач (doctors):**
- id – уникальный идентификатор
- last_name, first_name, patronymic – ФИО
- phone_number – телефон
- email – электронная почта (уникальный)

**Приём (appointments):**
- id – уникальный идентификатор
- patient_id – ссылка на пациента
- doctor_id – ссылка на врача
- scheduled_at – дата и время приёма
- status – статус (перечисление: scheduled, confirmed, in_progress, completed, cancelled, no_show)
- purpose – цель визита
- created_at – дата создания записи

Аналогично определены атрибуты для остальных сущностей.

## 2.2. Логическое проектирование

### 2.2.1. Преобразование ER-модели в реляционную схему

На этапе логического проектирования ER-модель была преобразована в реляционную схему с учётом правил нормализации.

**Правила преобразования:**

1. Каждая сущность превращается в таблицу
2. Атрибуты сущности становятся столбцами таблицы
3. Связь 1:N реализуется через внешний ключ в подчинённой таблице
4. Связь M:N реализуется через отдельную таблицу связи с составным первичным ключом
5. Связь 1:1 реализуется через внешний ключ с уникальным ограничением

**Пример преобразования связи M:N (Врач ↔ Специальность):**

Создана промежуточная таблица doctor_specialties:
- doctor_id (FK → doctors.id)
- specialty_id (FK → specialties.id)
- PRIMARY KEY (doctor_id, specialty_id) – составной ключ

### 2.2.2. Нормализация таблиц

Все таблицы базы данных приведены к третьей нормальной форме (3НФ).

**Пример таблицы patients:**

Исходная ненормализованная структура могла содержать адрес в виде одной строки: "Россия, Томск, ул. Ленина, д. 1, кв. 5".

После нормализации адрес разбит на отдельные атрибуты и вынесен в справочники:
- countries (страны)
- towns (города)
- streets (улицы)
- patients содержит ссылки на справочники и атрибуты building, apartment_number

**Достигнутые преимущества:**
- Исключена избыточность (название страны хранится один раз)
- Упрощено обновление данных (изменение названия города в одном месте)
- Обеспечена целостность (нельзя указать несуществующий город)
- Возможна фильтрация по городу без текстового поиска

### 2.2.3. Определение ограничений целостности

Для каждой таблицы определены ограничения:

**Ограничения первичных ключей:**
```sql
ALTER TABLE patients ADD PRIMARY KEY (id);
```

**Ограничения внешних ключей:**
```sql
ALTER TABLE appointments ADD FOREIGN KEY (patient_id)
    REFERENCES patients(id) ON DELETE RESTRICT;
```

Используется политика ON DELETE RESTRICT для защиты от случайного удаления записей, на которые есть ссылки.

**Ограничения уникальности:**
```sql
ALTER TABLE patients ADD UNIQUE (snils);
ALTER TABLE patients ADD UNIQUE (insurance_policy);
```

**Проверочные ограничения:**
```sql
ALTER TABLE patients ADD CHECK (date_of_birth <= CURRENT_DATE);
```

## 2.3. Физическая реализация в PostgreSQL

### 2.3.1. Создание типов-перечислений

Для типизированных атрибутов созданы пользовательские типы ENUM:

```sql
CREATE TYPE gender_type AS ENUM ('male', 'female');

CREATE TYPE room_type AS ENUM (
    'therapist',
    'general_practice',
    'pediatric',
    'specialist',
    'laboratory',
    'procedure',
    'administrative'
);

CREATE TYPE appointment_status AS ENUM (
    'scheduled',
    'confirmed',
    'in_progress',
    'completed',
    'cancelled',
    'no_show'
);
```

**Преимущества использования ENUM:**
- Строгая типизация на уровне СУБД
- Экономия памяти (хранится номер значения, а не строка)
- Автоматическая валидация при вставке
- Читаемость кода

### 2.3.2. Создание таблиц

Пример создания таблицы пациентов:

```sql
CREATE TABLE patients (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    patronymic VARCHAR(100),
    date_of_birth DATE NOT NULL
        CHECK (date_of_birth <= CURRENT_DATE),
    gender gender_type NOT NULL,
    phone_number VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    snils VARCHAR(14) UNIQUE,
    insurance_policy VARCHAR(16) UNIQUE,
    country_id INTEGER REFERENCES countries(id),
    town_id INTEGER REFERENCES towns(id),
    street_id INTEGER REFERENCES streets(id),
    building VARCHAR(10),
    apartment_number VARCHAR(10),
    zipcode VARCHAR(10)
);
```

Полный SQL-скрипт создания всех таблиц представлен в Приложении Б.

### 2.3.3. Создание индексов

Для оптимизации поиска созданы индексы на часто используемых полях:

```sql
-- Поиск по полису ОМС и СНИЛС
CREATE INDEX idx_patients_insurance_policy
    ON patients(insurance_policy);
CREATE INDEX idx_patients_snils
    ON patients(snils);

-- Поиск по ФИО
CREATE INDEX idx_patients_full_name
    ON patients(last_name, first_name, patronymic);

-- Фильтрация приёмов по дате
CREATE INDEX idx_appointments_scheduled_at
    ON appointments(scheduled_at);

-- Фильтрация по статусу
CREATE INDEX idx_appointments_status
    ON appointments(status);
```

**Оценка эффективности:**
Для таблицы из 1000 пациентов поиск по СНИЛС без индекса требует последовательного сканирования (Seq Scan), а с индексом – использование B-tree индекса (Index Scan), что ускоряет поиск в десятки раз.

### 2.3.4. Наполнение справочников

Справочники заполнены эталонными данными:

**Специальности врачей (16 записей):**
Терапевт, Кардиолог, Невролог, Эндокринолог, Отоларинголог, Хирург, Травматолог, Офтальмолог, Уролог, Педиатр, Гинеколог, Дерматолог, Психиатр, Стоматолог, Рентгенолог, УЗИ-специалист.

**Диагнозы МКБ-10 (29 записей):**
J00 – Острый назофарингит, J06.9 – ОРВИ, J11 – Грипп, J18.9 – Пневмония, J20.9 – Острый бронхит, I10 – Гипертензия, E11 – Сахарный диабет 2 типа и другие.

**Виды анализов (10 записей):**
Общий анализ крови, Биохимический анализ крови, Общий анализ мочи, Коагулограмма и другие.

Скрипт наполнения данными (seed_data.sql) представлен в Приложении В.

## 2.4. Разработка серверной части (Node.js + Express)

### 2.4.1. Структура серверного приложения

Серверная часть реализована на Node.js с использованием фреймворка Express. Структура проекта:

```
app/server/
├── index.js          # Точка входа
├── db.js             # Подключение к PostgreSQL
├── routes/           # Маршруты API
│   ├── patients.js
│   ├── doctors.js
│   ├── appointments.js
│   └── ...
└── package.json      # Зависимости проекта
```

### 2.4.2. Подключение к базе данных

Для работы с PostgreSQL используется библиотека pg (node-postgres):

```javascript
const { Pool } = require('pg');

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'policlinic',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD
});

module.exports = pool;
```

Использование пула соединений (Pool) позволяет эффективно управлять подключениями к базе данных и повторно использовать их для разных запросов.

### 2.4.3. Реализация REST API

Пример реализации CRUD-операций для сущности "Пациенты":

```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');

// GET /api/patients - получение списка пациентов с фильтрацией
router.get('/', async (req, res) => {
  try {
    const { gender, town_id, age_from, age_to, search } = req.query;
    let query = 'SELECT * FROM patients_view WHERE 1=1';
    const params = [];

    if (gender) {
      params.push(gender);
      query += ` AND gender = $${params.length}`;
    }
    if (town_id) {
      params.push(town_id);
      query += ` AND town_id = $${params.length}`;
    }
    // ... остальные фильтры

    const result = await pool.query(query, params);
    res.json(result.rows);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// POST /api/patients - создание нового пациента
router.post('/', async (req, res) => {
  try {
    const { last_name, first_name, date_of_birth, ... } = req.body;

    const result = await pool.query(
      `INSERT INTO patients (last_name, first_name, ...)
       VALUES ($1, $2, ...) RETURNING *`,
      [last_name, first_name, ...]
    );

    res.status(201).json(result.rows[0]);
  } catch (err) {
    if (err.code === '23505') { // Unique violation
      res.status(400).json({
        error: 'Пациент с таким полисом или СНИЛС уже существует'
      });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// PUT /api/patients/:id - обновление данных пациента
router.put('/:id', async (req, res) => {
  // Реализация обновления
});

// DELETE /api/patients/:id - удаление пациента
router.delete('/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM patients WHERE id = $1', [req.params.id]);
    res.status(204).send();
  } catch (err) {
    if (err.code === '23503') { // Foreign key violation
      res.status(400).json({
        error: 'Невозможно удалить пациента: есть связанные приёмы'
      });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

module.exports = router;
```

**Особенности реализации:**
- Использование параметризованных запросов для защиты от SQL-инъекций
- Обработка ошибок СУБД (коды 23505, 23503) с преобразованием в понятные пользователю сообщения
- Возврат корректных HTTP-статусов (200, 201, 400, 404, 500)
- Поддержка фильтрации через query-параметры

### 2.4.4. Использование представлений (views)

Для упрощения запросов созданы представления, объединяющие данные из нескольких таблиц:

```sql
CREATE VIEW patients_view AS
SELECT
    p.id,
    p.last_name,
    p.first_name,
    p.patronymic,
    p.date_of_birth,
    p.gender,
    p.phone_number,
    p.snils,
    p.insurance_policy,
    c.name as country,
    t.name as town,
    s.name as street,
    p.building,
    p.apartment_number
FROM patients p
LEFT JOIN countries c ON p.country_id = c.id
LEFT JOIN towns t ON p.town_id = t.id
LEFT JOIN streets s ON p.street_id = s.id;
```

Представление позволяет получать данные о пациенте с расшифровкой адреса одним запросом.

### 2.4.5. Экспорт данных в CSV

Реализована функция экспорта данных в формат CSV для анализа в Excel:

```javascript
router.get('/export/patients', async (req, res) => {
  const result = await pool.query('SELECT * FROM patients_view');

  // Формирование CSV с BOM для корректного отображения кириллицы
  const BOM = '\uFEFF';
  const header = 'ID,Фамилия,Имя,Отчество,Дата рождения,...\n';
  const rows = result.rows.map(row =>
    `${row.id},"${row.last_name}","${row.first_name}",...`
  ).join('\n');

  const csv = BOM + header + rows;

  res.setHeader('Content-Type', 'text/csv; charset=utf-8');
  res.setHeader('Content-Disposition', 'attachment; filename=patients.csv');
  res.send(csv);
});
```

## 2.5. Разработка клиентской части (React)

### 2.5.1. Архитектура клиентского приложения

Клиентская часть реализована на React с использованием функциональных компонентов и хуков. Структура проекта:

```
app/client/src/
├── main.jsx              # Точка входа
├── App.jsx               # Главный компонент с маршрутизацией
├── App.css               # Стили приложения
├── api.js                # Функции для работы с API
├── hooks/
│   └── useCrud.js        # Хук для CRUD-операций
└── components/
    ├── PatientsTable.jsx
    ├── DoctorsTable.jsx
    ├── FormModal.jsx     # Универсальный компонент формы
    ├── ConfirmModal.jsx  # Модальное окно подтверждения
    └── ...
```

### 2.5.2. Маршрутизация

Маршрутизация реализована с использованием React Router:

```javascript
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Navbar />
      <Container>
        <Routes>
          <Route path="/" element={<DoctorsTable />} />
          <Route path="/doctors" element={<DoctorsTable />} />
          <Route path="/patients" element={<PatientsTable />} />
          <Route path="/appointments" element={<AppointmentsTable />} />
          {/* ... остальные маршруты */}
        </Routes>
      </Container>
    </BrowserRouter>
  );
}
```

### 2.5.3. Универсальный хук для CRUD-операций

Создан переиспользуемый хук useCrud для работы с данными:

```javascript
export function useCrud(endpoint) {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const loadData = async (filters = {}) => {
    try {
      const result = await fetchData(endpoint, filters);
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const create = async (newItem) => {
    const created = await postData(endpoint, newItem);
    setData([...data, created]);
  };

  const update = async (id, updates) => {
    const updated = await putData(`${endpoint}/${id}`, updates);
    setData(data.map(item => item.id === id ? updated : item));
  };

  const remove = async (id) => {
    await deleteData(`${endpoint}/${id}`);
    setData(data.filter(item => item.id !== id));
  };

  useEffect(() => { loadData(); }, [endpoint]);

  return { data, loading, error, create, update, remove };
}
```

### 2.5.4. Компонент таблицы с фильтрацией

Пример компонента PatientsTable:

```javascript
function PatientsTable() {
  const { data, loading, error, create, update, remove } = useCrud('/patients');
  const [showForm, setShowForm] = useState(false);
  const [editItem, setEditItem] = useState(null);
  const [filterValues, setFilterValues] = useState({
    gender: '',
    town_id: '',
    age_from: '',
    age_to: ''
  });

  const handleFilterChange = (e) => {
    const { name, value } = e.target;
    setFilterValues(prev => ({ ...prev, [name]: value }));
  };

  const handleApplyFilters = () => {
    applyFilters(filterValues);
  };

  if (loading) return <Spinner />;
  if (error) return <Alert variant="danger">{error}</Alert>;

  return (
    <>
      <h2>Пациенты</h2>
      <Button onClick={() => setShowForm(true)}>+ Добавить</Button>

      {/* Панель фильтров */}
      <Card>
        <Form.Group>
          <Form.Label>Пол</Form.Label>
          <Form.Select name="gender" onChange={handleFilterChange}>
            <option value="">Все</option>
            <option value="male">Мужской</option>
            <option value="female">Женский</option>
          </Form.Select>
        </Form.Group>
        <Button onClick={handleApplyFilters}>Применить</Button>
      </Card>

      {/* Таблица данных */}
      <Table>
        <thead>
          <tr>
            <th>ID</th>
            <th>ФИО</th>
            <th>Дата рождения</th>
            <th>Действия</th>
          </tr>
        </thead>
        <tbody>
          {data.map(patient => (
            <tr key={patient.id}>
              <td>{patient.id}</td>
              <td>{patient.last_name} {patient.first_name}</td>
              <td>{formatDate(patient.date_of_birth)}</td>
              <td>
                <Button onClick={() => handleEdit(patient)}>Изм.</Button>
                <Button onClick={() => handleDelete(patient.id)}>Уд.</Button>
              </td>
            </tr>
          ))}
        </tbody>
      </Table>

      <FormModal
        show={showForm}
        onHide={() => setShowForm(false)}
        fields={fields}
        initialData={editItem}
        onSubmit={editItem ? update : create}
      />
    </>
  );
}
```

### 2.5.5. Универсальный компонент формы

Создан переиспользуемый компонент FormModal, принимающий конфигурацию полей:

```javascript
function FormModal({ show, onHide, title, fields, initialData, onSubmit }) {
  const [formData, setFormData] = useState(initialData || {});
  const [error, setError] = useState(null);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Обрезка пробелов
    const trimmedData = Object.keys(formData).reduce((acc, key) => {
      const value = formData[key];
      acc[key] = typeof value === 'string' ? value.trim() : value;
      return acc;
    }, {});

    try {
      await onSubmit(trimmedData);
      onHide();
    } catch (err) {
      setError(err.message);
    }
  };

  return (
    <Modal show={show} onHide={onHide}>
      <Form onSubmit={handleSubmit}>
        <Modal.Header>
          <Modal.Title>{title}</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {error && <Alert variant="danger">{error}</Alert>}
          {fields.map(field => (
            <Form.Group key={field.name}>
              <Form.Label>{field.label}</Form.Label>
              {field.type === 'select' ? (
                <Form.Select
                  name={field.name}
                  value={formData[field.name] || ''}
                  onChange={handleChange}
                  required={field.required}
                >
                  <option value="">Выберите...</option>
                  {field.options.map(opt => (
                    <option key={opt.value} value={opt.value}>
                      {opt.label}
                    </option>
                  ))}
                </Form.Select>
              ) : (
                <Form.Control
                  type={field.type || 'text'}
                  name={field.name}
                  value={formData[field.name] || ''}
                  onChange={handleChange}
                  required={field.required}
                />
              )}
            </Form.Group>
          ))}
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={onHide}>Отмена</Button>
          <Button variant="primary" type="submit">Сохранить</Button>
        </Modal.Footer>
      </Form>
    </Modal>
  );
}
```

**Преимущества подхода:**
- Компонент FormModal переиспользуется для всех сущностей
- Конфигурация полей задаётся декларативно
- Автоматическая валидация обязательных полей
- Единообразный UX для всех форм

### 2.5.6. Обработка ошибок в UI

Реализована визуализация ошибок для пользователя:

```javascript
const confirmDelete = async () => {
  try {
    await remove(deleteId);
    setShowDelete(false);
  } catch (err) {
    setDeleteError(err.message); // Отображается в модальном окне
  }
};

<ConfirmModal
  show={showDelete}
  onConfirm={confirmDelete}
  error={deleteError}
  title="Удалить пациента"
  message="Вы уверены?"
/>
```

При попытке удалить пациента, у которого есть приёмы, пользователь увидит сообщение: "Невозможно удалить пациента: есть связанные приёмы".

## 2.6. Тестирование и отладка

### 2.6.1. Тестирование CRUD-операций

Проведено функциональное тестирование всех CRUD-операций:

**Создание записи (Create):**
- Позитивный сценарий: создание пациента с корректными данными – успешно
- Негативный сценарий: создание с дубликатом СНИЛС – ошибка "Пациент с таким СНИЛС уже существует"
- Граничный случай: создание с минимальным набором полей – успешно

**Чтение записей (Read):**
- Получение всех записей – успешно
- Фильтрация по полу – выборка соответствует критерию
- Фильтрация по возрасту (30-50 лет) – корректная выборка
- Фильтрация с пустым результатом – таблица пустая, нет ошибок

**Обновление записи (Update):**
- Позитивный сценарий: изменение телефона пациента – данные обновлены
- Негативный сценарий: изменение СНИЛС на существующий – ошибка уникальности

**Удаление записи (Delete):**
- Позитивный сценарий: удаление пациента без приёмов – успешно
- Негативный сценарий: удаление пациента с приёмами – ошибка "есть связанные приёмы"

### 2.6.2. Тестирование связей между сущностями

**Сценарий "Запись на приём":**
1. Создать приём для пациента и врача – успешно
2. Проверить, что в выпадающих списках отображаются данные из связанных таблиц – корректно
3. Попытаться удалить врача с приёмами – ошибка защиты целостности

**Сценарий "Создание медицинской записи":**
1. Создать мед. запись с выбором приёма – успешно
2. Проверить, что пациент подтягивается автоматически из выбранного приёма – работает
3. Назначить диагноз из справочника МКБ-10 – корректно

**Сценарий "Назначение анализа":**
1. Назначить анализ на приёме – создан со статусом "Ожидает"
2. Внести результат и дату выполнения – статус изменился на "Выполнен"
3. Попытаться указать дату выполнения раньше даты назначения – ошибка валидации

### 2.6.3. Тестирование производительности

**Тест 1: Поиск пациента по СНИЛС**
- Без индекса: 45 мс (Seq Scan на 1000 записей)
- С индексом: 2 мс (Index Scan)
- Ускорение: в 22 раза

**Тест 2: Фильтрация приёмов по дате**
- Без индекса на scheduled_at: 38 мс
- С индексом: 4 мс
- Ускорение: в 9 раз

**Тест 3: Экспорт 500 пациентов в CSV**
- Время генерации: 120 мс
- Размер файла: 85 КБ
- Корректность кодировки: кириллица отображается без искажений

### 2.6.4. Обнаруженные и устраненные ошибки

**Проблема 1: Некорректное отображение кириллицы в CSV**
Решение: Добавлен BOM (Byte Order Mark) в начало файла: `const BOM = '\uFEFF';`

**Проблема 2: Телефоны в CSV преобразуются в числа**
Решение: Экранирование значений кавычками: `"${row.phone_number}"`

**Проблема 3: Отсутствие визуального feedback при удалении с ошибкой**
Решение: Добавлен state deleteError и отображение в модальном окне

**Проблема 4: Пробелы в начале и конце строк сохраняются в БД**
Решение: Добавлен автоматический trim всех строковых полей при отправке формы

**Проблема 5: NavDropdown не подсвечивается при активной вложенной странице**
Решение: Добавлена логика определения активности dropdown на основе текущего маршрута

---

# ЗАКЛЮЧЕНИЕ

В результате выполнения курсовой работы была разработана полнофункциональная информационная система учёта пациентов и приёмов в поликлинике на основе реляционной СУБД PostgreSQL.

## Достигнутые результаты:

1. **Спроектирована реляционная база данных**, включающая 22 таблицы, приведённые к третьей нормальной форме. Разработана концептуальная модель в виде ER-диаграммы, логическая схема с определением всех связей и ограничений целостности.

2. **Реализована физическая модель в PostgreSQL** с использованием пользовательских типов ENUM, индексов для оптимизации запросов, представлений для упрощения выборки данных. Создан скрипт наполнения справочников эталонными данными (специальности, диагнозы МКБ-10, виды анализов).

3. **Разработано серверное приложение на Node.js**, предоставляющее REST API с более чем 30 эндпоинтами для выполнения CRUD-операций, фильтрации данных и экспорта отчётов. Реализована обработка ошибок СУБД с преобразованием в понятные пользователю сообщения.

4. **Создано клиентское веб-приложение на React** с интуитивно понятным пользовательским интерфейсом. Реализованы универсальные компоненты для работы с формами, фильтрации данных, экспорта в CSV. Добавлена визуальная подсветка активных элементов навигации.

5. **Проведено комплексное тестирование** системы на типовых и граничных сценариях. Выявлены и устранены ошибки, связанные с кодировкой, валидацией данных и отображением ошибок в UI.

## Практическая значимость:

Разработанная система может быть использована в медицинских учреждениях амбулаторного типа для:
- Ведения электронного реестра пациентов с возможностью быстрого поиска по различным критериям
- Управления расписанием приёмов врачей и записи пациентов
- Ведения медицинской документации с использованием классификатора МКБ-10
- Назначения и отслеживания результатов анализов
- Формирования отчётности для административного учёта

## Перспективы развития:

1. **Система авторизации и разграничения прав доступа** – реализация ролей (администратор, врач, регистратор) с различными уровнями доступа к функциональности.

2. **Модуль уведомлений** – автоматическая отправка SMS/Email-напоминаний пациентам о предстоящих приёмах, готовности результатов анализов.

3. **Интеграция с внешними системами** – обмен данными с региональными медицинскими информационными системами, электронными рецептами.

4. **Аналитические отчёты** – дашборды с графиками заболеваемости, статистикой посещений, анализом загруженности врачей.

5. **Мобильное приложение** – версия для смартфонов для удобного доступа к расписанию и медицинским картам.

6. **Электронная медицинская карта** – расширенная функциональность для хранения результатов обследований, заключений специалистов, истории назначений.

Таким образом, поставленные цели курсовой работы достигнуты в полном объёме. Разработанная система демонстрирует применение теоретических знаний по проектированию баз данных на практике и может служить основой для создания промышленного решения в сфере медицинской информатизации.

---

# СПИСОК ИСПОЛЬЗОВАННОЙ ЛИТЕРАТУРЫ

1. Дейт К. Дж. Введение в системы баз данных. 8-е издание. – М.: Вильямс, 2005. – 1328 с.

2. Кузнецов С. Д. Основы баз данных. 2-е издание. – М.: Интернет-Университет Информационных Технологий, 2007. – 484 с.

3. Грабер М. SQL. Справочное руководство. – М.: Лори, 2003. – 290 с.

4. PostgreSQL: Documentation / Official PostgreSQL Documentation. – URL: https://www.postgresql.org/docs/ (дата обращения: 20.12.2024).

5. Express.js Documentation / Express framework for Node.js. – URL: https://expressjs.com/ (дата обращения: 20.12.2024).

6. React Documentation / Official React Documentation. – URL: https://react.dev/ (дата обращения: 20.12.2024).

7. Международная статистическая классификация болезней и проблем, связанных со здоровьем (МКБ-10) / Всемирная организация здравоохранения. – URL: https://icd.who.int/browse10/2019/en (дата обращения: 15.11.2024).

8. Флэнаган Д. JavaScript. Подробное руководство. 7-е издание. – СПб.: Питер, 2021. – 720 с.

9. Моргун А. Node.js. Разработка серверных веб-приложений на JavaScript. – СПб.: Питер, 2018. – 304 с.

10. Бэнкс А., Порчелло Е. React и Redux: функциональная веб-разработка. – СПб.: Питер, 2019. – 336 с.

---

# ПРИЛОЖЕНИЯ

## Приложение А. ER-диаграмма базы данных

_(Здесь должна быть вставлена ER-диаграмма из файла policlinic.svg или conceptual_model.md)_

**Описание:**
На диаграмме представлены основные сущности системы:
- Пациент (PATIENT)
- Врач (DOCTOR)
- Приём (APPOINTMENT)
- Медицинская запись (MEDICAL_RECORD)
- Диагноз (DIAGNOSIS)
- Анализ (ANALYSIS)
- Назначения лекарств и процедур
- Справочники (специальности, кабинеты, адреса)

Связи обозначены с указанием кардинальности:
- ||--o{ – один ко многим
- }o--o{ – многие ко многим
- ||--|| – один к одному

## Приложение Б. SQL-скрипт создания структуры базы данных

```sql
-- Полный скрипт создания таблиц представлен в файле policlinic_postgresql.sql
-- Основные секции:

-- 1. Создание типов-перечислений
CREATE TYPE gender_type AS ENUM ('male', 'female');
CREATE TYPE room_type AS ENUM (...);
CREATE TYPE appointment_status AS ENUM (...);

-- 2. Создание справочных таблиц
CREATE TABLE countries (...);
CREATE TABLE towns (...);
CREATE TABLE specialties (...);
CREATE TABLE diagnoses (...);

-- 3. Создание основных таблиц
CREATE TABLE patients (...);
CREATE TABLE doctors (...);
CREATE TABLE appointments (...);
CREATE TABLE medical_records (...);

-- 4. Создание промежуточных таблиц для связей M:N
CREATE TABLE doctor_specialties (...);

-- 5. Создание индексов
CREATE INDEX idx_patients_snils ON patients(snils);
CREATE INDEX idx_appointments_scheduled_at ON appointments(scheduled_at);

-- 6. Создание представлений
CREATE VIEW patients_view AS SELECT ...;
```

## Приложение В. Примеры запросов

**1. Получение списка пациентов с адресами:**
```sql
SELECT
    p.id,
    p.last_name || ' ' || p.first_name as full_name,
    p.date_of_birth,
    c.name as country,
    t.name as town,
    s.name as street,
    p.building
FROM patients p
LEFT JOIN countries c ON p.country_id = c.id
LEFT JOIN towns t ON p.town_id = t.id
LEFT JOIN streets s ON p.street_id = s.id
ORDER BY p.last_name;
```

**2. Поиск врачей определённой специальности:**
```sql
SELECT
    d.last_name,
    d.first_name,
    STRING_AGG(sp.name, ', ') as specialties
FROM doctors d
JOIN doctor_specialties ds ON d.id = ds.doctor_id
JOIN specialties sp ON ds.specialty_id = sp.id
WHERE sp.name = 'Терапевт'
GROUP BY d.id, d.last_name, d.first_name;
```

**3. Приёмы на сегодня:**
```sql
SELECT
    a.id,
    a.scheduled_at,
    p.last_name || ' ' || p.first_name as patient_name,
    d.last_name || ' ' || d.first_name as doctor_name,
    a.status
FROM appointments a
JOIN patients p ON a.patient_id = p.id
JOIN doctors d ON a.doctor_id = d.id
WHERE DATE(a.scheduled_at) = CURRENT_DATE
ORDER BY a.scheduled_at;
```

**4. Статистика по диагнозам:**
```sql
SELECT
    dg.code,
    dg.name,
    COUNT(mr.id) as diagnoses_count
FROM diagnoses dg
LEFT JOIN medical_records mr ON dg.id = mr.diagnosis_id
GROUP BY dg.id, dg.code, dg.name
ORDER BY diagnoses_count DESC;
```

**5. Пациенты без полиса ОМС:**
```sql
SELECT
    id,
    last_name,
    first_name,
    phone_number
FROM patients
WHERE insurance_policy IS NULL OR insurance_policy = ''
ORDER BY last_name;
```

## Приложение Г. Скриншоты интерфейса приложения

_(Здесь должны быть вставлены скриншоты основных экранов системы)_

**1. Главная страница – список врачей**
- Таблица с данными врачей
- Панель фильтров
- Кнопки добавления, редактирования, удаления

**2. Форма добавления пациента**
- Поля ввода персональных данных
- Выпадающие списки для адреса
- Маски ввода для СНИЛС и телефона
- Валидация обязательных полей

**3. Страница приёмов с фильтрацией**
- Фильтры по дате, статусу, врачу, пациенту
- Счётчик активных фильтров
- Отображение статусов цветными бейджами

**4. Модальное окно с ошибкой удаления**
- Сообщение о невозможности удаления
- Объяснение причины (наличие связанных записей)

**5. Страница выборок**
- Карточки с готовыми отчётами
- Результаты выборки в табличном виде

---

**КОНЕЦ ДОКУМЕНТА**

_Медведева Ю.Е._
_Курсовая работа по дисциплине «Базы данных»_
_ТУСУР, 2024_
